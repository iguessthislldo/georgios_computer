dec|hex|bin    |name |ALU OP|DESCRIPTION                          |ARGUMENTS      |
---+---+-------+-----+------+-------------------------------------+---------------+
00 |00 |000000 |nop  |      |Do nothing                           |_ _ _ 00 0 000 |
01 |01 |000001 |=    |      |Set %A to B                          |R I _ 10 1 100 |
02 |02 |000010 |save |      |Set memory at A to B                 |I I _ 10 0 000 |
03 |03 |000011 |load |      |Set %A to memory at B                |R I _ 10 1 100 |
04 |04 |000100 |if   |      |If %A go to B                        |R I _ 10 1 100 |
05 |05 |000101 |goto |      |Jump to A                            |I _ _ 01 0 000 |
06 |06 |000110 |if!  |      |If not %A go to B                    |R I _ 10 1 100 |
07 |07 |000111 |.....|......|.............................Reserved|...............|
08 |08 |001000 |in   |      |Read Input(%B, %C) to %A             |R R R 11 0 111 |
09 |09 |001001 |out  |      |Write A to Output(%B, %C)            |I R R 11 0 011 |
...|...|.......|.....|......|.............................Reserved|...............|
32 |20 |100000 |+    |00000 |Set %A to B add C                    |R I I 11 1 100 |
33 |21 |100001 |-    |00001 |Set %A to B subtract C               |R I I 11 1 100 |
34 |22 |100010 |++   |00010 |Increment %A                         |R _ _ 01 0 100 |
35 |23 |100011 |--   |00011 |Decrement %A                         |R _ _ 01 0 100 |
36 |24 |100100 |*u   |00100 |Set %A to unsigned mult. of B and C  |R I I 11 1 100 |
37 |25 |100101 |/u   |00101 |Set %A to unsigned div. of B and C   |R I I 11 1 100 |
38 |26 |100110 |*s   |00110 |Set %A to signed mult. of B and C    |R I I 11 1 100 |
39 |27 |100111 |/s   |00111 |Set %A to signed div. of B and C     |R I I 11 1 100 |
40 |28 |101000 |&&   |01000 |Set %A to B logical and C            |R I I 11 1 100 |
41 |29 |101001 |||   |01001 |Set %A to B logical or C             |R I I 11 1 100 |
42 |2A |101010 |<<   |01010 |Set %A to B logical shift left C     |R I I 11 1 100 |
43 |2B |101011 |>>   |01011 |Set %A to B logical shift right C    |R I I 11 1 100 |
44 |2C |101100 |>>>  |01100 |Set %A to B arithmatic shift right C |R I I 11 1 100 |
45 |2D |101101 |&    |01101 |Set %A to B bitwise and C            |R I I 11 1 100 |
46 |2E |101110 ||    |01110 |Set %A to B bitwise or C             |R I I 11 1 100 |
47 |2F |101111 |^    |01111 |Set %A to B bitwise xor C            |R I I 11 1 100 |
48 |30 |110000 |==   |10000 |Set %A to B equals C                 |R I I 11 1 100 |
49 |31 |110001 |!=   |10001 |Set %A to B not equals C             |R I I 11 1 100 |
50 |32 |110010 |>    |10010 |Set %A to B greater than C           |R I I 11 1 100 |
51 |33 |110011 |>=   |10011 |Set %A to B greater than equal to C  |R I I 11 1 100 |
52 |34 |110110 |<    |10110 |Set %A to B less than C              |R I I 11 1 100 |
53 |35 |110111 |<=   |10111 |Set %A to B less than equal to C     |R I I 11 1 100 |
54 |36 |111000 |~    |11000 |Set %A to bitwise not B              |R I _ 10 1 100 |
55 |37 |111001 |!    |11001 |Set %A to logical not B              |R I _ 10 1 100 |
...|...|.......|.....|......|.............................Reserved|...............|
63 |3F |111111 |halt |      |Halt the computer                    |_ _ _ 00 0 000 |

